# EBNF

## 介绍

句法元语言时计算机科学中非常重要的一个工具。其基本原理是公开的，但是存在着各种略有差异的标记。这导致句法元语言仍未能被广泛的理解和接受，这些乏味枯燥的记号无法被大多数人承认其优势。

*Extended BNF* 为形式化语法定义带来新的秩序，并且这不仅仅是对编程语言的定义有用，而是对其他形式化定义都有着同样的用武之地。

自 1960 年 Algol 60 编程语言问世以来，人们就已经习惯形式化的定义一门编程语言的语法。Algol 60 使用了巴科斯范式记号，这种记号被后语言证实非常适合作为一个基底，但被频繁的扩展和小幅替换。很多不同的记号令人感到困惑，并失去了形式化无歧义定义的优势，这导致其无法被广泛的接受。本标准中所描述的句法元语言 *Extended BNF* 建立在巴科斯范式基础之上，并且包含大量被广泛采用的扩展。

### 句法元语言

句法元语言是一种通过大量规则来定义一门语言语法的记号。每一个规则命名了语言的一部分（被称为语言的非终止符）并定义该部分可能的形式。一门语言的一个终止符号是一个无法被分割为更小的语言组件的原子部分。句法元语言在需要清晰的形式化描述和定义的情况下非常有用，比如：向期刊投稿论文时的参考资料格式，或者用来致性复杂任务的指令。

形式化语法定义有三种不同的用法：

1. 用来命名语言的各个不同的句法部分（比如，非终止符）；
2. 用来展示哪些符号序列是语言的有效句子；
3. 用来展示语言中任意句子的语法结构

### 标准句法元语言的必要性

如果没有一个标准的句法元语言来让每一个编程语言作为基础来定义它的语法，那么将导致各种问题：

+ 大量不同的记号——很难让不同的编程语言使用相同的元语言。这导致学习新的编程语言之前就必须新的元语言。
+ 概念无法被广泛的理解—— 标准记号的缺失阻碍严谨的无歧义的定义的使用
+ 不完美的记号——由于每一个编程语言都需要定义一个元语言，那么不可避免的导致元语言包含缺陷。比如 RTL/2 (BS5904) 草案和 CORAL 66 (BS5905)  中的错误就是因为它们的元语言无法被轻易的键入。
+ 特殊目的记号——用于特殊编程语言的元语言通常会使用语言中的特殊特性来简化定义。但是这种元语言无法适用于其他编程语言
+ 缺少通用语法处理器——语法元语言的多样性限制了计算机程序分析和处理语法的能力，比如：整齐的列初语法，以及为语法中使用的符号进行编号，还包括编写语法检查工具。

实际上，有经验的读者在学习新的记号方面几乎没有障碍，但即便如此，这些元语言之间的差异导致理解上的模糊边界并阻碍了交流。一个标准的元语言可以让更多的人将模糊的想法结晶为一个无歧义的定义。另外，其他需要提供形式化定义的人们无需重复的发明相似的概念。

### 需要达成的目标

一个令人满意的标准句法元语言需要达成如下目标：

1. 间接，这样语言就可以被间接的定义，并且理解起来会更简单；
2. 精准，这样一来，规则将无歧义；
3. 形式化，这样一来，规则便可以被解析从而可以被计算机处理；
4. 自然，记号和格式会相对简单一点，便于学习理解，甚至对那些非编程语言设计者来讲，也更容易理解。（符号的含义不应当令人感到诧异。所定义出的语法应能帮助表示含义）
5. 通用，记号可以用作各种目的，包括不同语言的描述
6. 字符集应当简单，尽量使用标准键盘中可以键入的字符
7. 能够自我描述
8. 线性的，能够保证语法可以通过单个字符流表达出来。（这样能够简化语法的打印，并简化计算机的处理）

### 一些常规的句法元语言

很不幸的是没有哪一个现有的句法元语言能够被采纳为标准，比如：

1. COBOL (ISO 1989:1985) 垂直列出可替代品，并使用跨多行的括弧。者在计算机处理上很不方便。
2. 巴科斯范式中的元符号 `< > | ::=` 可能和编程语言中的符号有冲突，这时候会引发一些问题。一些常用的结构形式无法自然的表现出来（比如注释），还有一些结构过于冗长（比如循环）。
3. 废弃的 FORTRAN 77 (ISO 1539:1980) 拥有“铁路轨道”。这种形式很容易理解，但是很难准备并且难以处理。FORTRAN 当前版 FORTRAN 90 (ISO/IEC 1539:1991) 不再使用这种记号。

大部分其他语言使用这些元语言中的一个变种。他们中的大部分都无法作为标准化的候选者，因为他们使用的字符不是元语言中定义为原符号的字符。这种做法可能会简化元语言，但无法让其变得通用。

POSIX (ISO/IEC 9945-2:1993) 包含两个辅助性的机制，这两个机制都假设 ISO/IEC 646:1991 字符集可以被使用：LEX 允许定义正则表达式，并对其进行词法分析，但是不足以对一个任意上下文无关的语法进行描述。YACC (Yet Another Compiler Compiler) 是一个 LALR 语法的解析生成器。

### 标准元语言：扩展的巴科斯范式

Extended BNF，是本国际标准中定义的元语言，建立在 BNF 基础之上，并包含大量常用扩展，如：

1. 语言的终止符被引号包含，从而任何字符都可以被作为终止符号
2. `[`和`]` 表示可选符号
3. `{` 和 `}` 表示重复
4. 每一个规则都有一个显式的最终字符，因此不会出现规则结束位置上的歧义
5. 括弧将多个东西作为一组。将 `()` 作为数学意义使用显然会很方便。

EBNF 的主要不同之处在于提供形式化定义所提供的特性：

1. 定义显式数量的物体。Fortran 包含一个规则：标签字段只能包含 5 个字符；PL/I 或 COBOL 中的标识符最多拥有 32 个字符。这些规则在 BNF 中很难表达。实际上这种定义往往不完整或者使用非正式的英语表达。
2. 通过少量的意外示例来定义某些东西。一个 Algol 注释结尾在第一个 `end`、`else` 或者分号后结束。这种规则在 BNF 中很难表述
3. 包含注释。编程语言和其他包含复杂语法的结构需要很多规则来定义他们。如果可以提供解释和交叉引用，那么语法将会更加清晰。相应的 EBNF 中包含注释机制，从而可以在语法中添加普通文本，以便在不影响语法的形式含义的同时方便人类阅读。
4. 元标识符：一个元标识符（语言中非终止符的名字）不一定费的是单个字或者因为由显式的连接符号而使用括弧包含。这同样确保语法布局不影响语言定义。
5. 扩展。用户可能会期望扩展 EBNF。一些特殊序列便是出于此目的而提供，扩展的具体形式没有在标准中定义，只是确保了扩展的起始和结束能够被轻松的定义。各种可能的扩展会在下面的段落中列出。

### 局限性和扩展

EBNF 的组要局限性在于其所定义的语言需要是线性的。比如，语言的句中的符号需要放在一个有序序列中。比如编织图案和烹饪食谱是线性语言，但是电路图不是。

另一个局限性是：EBNF 不足以定义更复杂形式的语法。

相反，EBNF 被设计为能够以一种自然的方式进行扩展。有两种方式扩展标准元语言。首先：特殊序列原理为任何扩展提供基本框架，特殊序列字符之间的格式几乎可以是任意的。这种方式适用于行为与法，比如指定一个句子解析之后的行为。其次，元标识符从来不会跟在做括弧之后，；因此另一种扩展元语言的方法是定义一个元标识符后面紧跟着被圆括弧包含的参数序列。这在属性语法中很合理，规则可以确保定义的语言的句子的不同部分的一致性。

更复杂的扩展也是可能的。附录 A 给出如何使用 EBNF 扩展定义二级语法的相关建议。

